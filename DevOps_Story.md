# **القصة وما فيها: من مجرد فكرة لحد ما يبقا عندنا ابلكيشن**

إحنا شركة ناشئة قررت تبني تطبيق بنكي جديد من الصفر. معانا (المبرمج) و (مهندس الديف أوبس) و الـ`Tester` اللي هيختبر التطبيق بعد ما يتبني. كل واحد فيهم عنده دور مهم في القصة دي.

## **اول مرحلة: (Sprint Zero)**

في البداية، مهندس الـDevOps بيبدأ الشغل على لابتوبه مهمته إنه يبني ال Infrastructure اللي هيشتغل عليهم التطبيق. بيفتح محرر الأكواد وبيبدأ يكتب كود بأداة اسمها **Terraform**. 

الكود ده بيوصف البنية التحتية المطلوبة على الكلاود (زي AWS). لكنه مش بيبني بنية تحتية ضخمة ومكلفة من أول يوم، هو بيبني يا دوبك بيئة تجريبية (**`Staging Environment`**) صغيرة جداً ورخيصة.

وهنا ممكن حد يسأل، **مش كدا أنا بدفع فلوس على خدمات لسه مش بستخدمها؟**. الإجابة هي لأ، لأن مهندس الـDevOps بذكاء بدأ ببيئة صغيرة جداً ورخيصة فالاول ، وكود الـ `Terraform` بيسمحله يكبرها بسهولة بعدين لما الضغط على التطبيق يزيد، كمان النقطة دي بتبقا علي حسب الابلكيشن و التيم. 

الخطوة الجاية، وفي معظم الشركات المنظمة، اللي بيعمل الريبو الي هيترفع عليه الكود (**Repository**) على **GitHub** هو ال Team Lead أو ممكن المبرمج نفسه.

مهندس الDevOps هنا عليه مسؤوليه انه يحمي الريبو يعني مثلا ميسمحش لاي حد كدا انه يعمل push ع الmain branch مثلا

بعد ما ال Team Lead بيعمل الريبو، بيبعت اللينك لمهندس الديف أوبس وفريق العمل. وهنا بيجي دور أدوات تنظيم الشغل و الـCommunication.

الفريق بيستخدم أداة اسمها **Jira** عشان ينظم كل الشغل المطلوب في شكل مهام أو (Tickets)، كل مهمة ليها وصف وصاحب وميعاد.

والتواصل اللحظي بين الفريق بيتم عن طريق **Slack** ممكن تعتبره زي جروب واتساب كدا بس حاجة `Profissional`. 

المبرمج بياخد لينك الريبو من ع Slack ده وبيستخدم أداة **Git** عشان يعمل `clone` للمشروع على جهازه، وبكده بقى معاه نسخة كاملة.

مهندس الـDevOps كمان بيعمل `clone` للمشروع. طيب **مهندس الديف أوبس هيستفيد إيه لما يكون عنده نسخة من المشروع؟**.

لأنه بيحتاجها عشان يفهم هيكل التطبيق، ويقدر يعدل على الملفات الخاصة بالديف أوبس اللي عايشة جوه المشروع نفسه زي الـ `Dockerfile` والـ `CI/CD script`، ويقدر يجرب التعديلات دي عنده الأول قبل ما يطبقها على النظام كله.

## **المرحلة الثانية: أول كود (Sprint 1)**

الفريق بيتبع منهجية الـ **Agile**:

وهي ببساطة فلسفة بتقول إننا نشتغل على أجزاء صغيرة ونخلّصها بسرعة. الأجزاء دي بنشتغل عليها في فترة زمنية ثابتة، غالبًا أسبوعين، اسمها **`Sprint`**.

وفي أول `Sprint`، هدفهم هو عمل ميزة "تسجيل الدخول" مثلا.

قبل ما فني الكود يكتب أي كود، أول حاجة بيعملها إنه بيكتب أمر في `Git` عشان يعمل فرع جديد لنفسه اسمه `feature/login`.

العمل على **`Branches`** منفصلة هي القاعدة الأساسية عشان الشغل يبقى منظم ومحدش يبوظ كود التاني.

إذن **هل أول حاجة بعملها على الريبو هو branch جديد قبل ما اعمل اي commits خالص؟**. أيوه، من ال`Best Practices`، شغلك بيبدأ من فرع جديد.

في الوقت ده، مهندس الـDevOps بيخلص كتابة **`CI/CD Scripts`**، اللي هي هتشغل النظام . وده بيورينا الترتيب المنطقي للشغل:

الأول جهزنا `Infrastructure` بـ`Terraform`،  -->  بعدين الريبو بـ `GitHub`  --> ودلوقتي بنبني ال `Pipelines` بـ `CI/CD Scripts`.

صنايعي الكود خلص شغله الي كان شغال عليه خلاص وعمل `Commit` وبعدها عمل `bush` على `GitHub`.
 
وهنا بقا فقرة الساحر، الـ `CI Pipeline` اللي بيشغله أداة زي **`Jenkins`** بيبدأ يشتغل لوحده. الـ `Pipeline` ده عبارة عن مجموعة مراحل أو **`stages`**.

> ### أول `stage` ممكن تكون عبارة عن **`Bash Script`** بسيط عشان يجهز بيئة العمل. 

> ### بعدها في `Stage` بتعمل `Build`لملفات المشروع

والـ`Output` بتاعها بيكون اسمه `Artifact` دي حاجة زي لما بتنزل برنامج من عن النت وتعمله فك ضغط وتلاقي ملف اسمه `حاجة.exe`. 

> ### بعدين بتيجي مرحلة الـ`Testing`.

الـ `Pipeline` بياخد الـ`Artifact` ده وبيعمل `Testing` للابلكيشن هو مش بيخترع الـ`Test Cases` من نفسه اكيد، هو بس بينفذ أوامر معينه زي مثلا  `npm test`.

الأمر ده بدوره بيشغل كل ملفات الـ`Testing` اللي بتاع الكود كتبها بنفسه جنب الكود بتاعه او ال Tester.

تخيل إن اختبار فشل. نظام الـ CI/CD بيربط الـ `push` بالمبرمج وبيوقف كل حاجة. **بيفهم المشكلة منين وازاي بيقدر يعرف يبعت لصاحب المشكلة؟**.

لأنه عارف مين هو صاحب الكود (الي عمل الpush ده) ، بيبعتله  إشعار فوري على `Slack` بالإيميل مع رابط مباشر للـ `log` اللي فيه رسالة الخطأ بالظبط.

**`مش شرط SLACK  اي يعني Tool عادي احنا بنتفق عليها`**

بعد ما بتاع الكود يصلح المشكلة وكل الـ`Test Cases` تبقا `successful،` الـ `Pipeline` بينتقل لمرحلة جديدة
> ## التغليف `Packeging`.
هنا بيقرأ ملف اسمه **`Dockerfile`** الي بيبقا مكتوب ومحطوط جمب الكود كدا زي ما شوفنا ف الـLabs

وبيستخدم أداة **`Docker`** عشان يبني `Isolated Container` زي ما فهمنا بقا.

كدا احنا بقا معانا **`Container`** عليه الابلكيشن بتاعنا بس لسه  محشور جوا الـ Pipeline   

#### ملحوظة
> ممكن يبقا في اكتر من `stage` مش شرط دول بس يعني بس دول ف العادة اساسيين في اي `CI Pipeline`.

---
## **المرحلة الثالثة: من مجرد Container لـ App الناس بتستخدمه**

هنا بقا ييجي دور الـ **`CD Pipeline`** الي كان اتكتب ف الاول خالص لو فاكر 

الـ CD Pipeline دلوقتي جاهز عشان ينشر التطبيق. هو بياخد الـ **`Docker Image`** (الـDescription الي بيوصف الContainer بالظبط واي هي وظيفته لما يشتغل) الي بتطلع من ال CI Pipeline ويسلمها للبطل الأخير في القصة، **`Kubernetes`** الي بيعمل **`Deploy`** للابلكيشن ع السيرفر او السيرفراااات  سواء كانت   `Onprim` او ع `الكلاود` 


مهندس الـDevOps بيكون محدد في ملفات إعدادات `Kubernetes` إنه محتاج مثلاً 3 نسخ من التطبيق شغالة دايماً. طيب **هو لما (K8s) Kubernetes بيشتغل انا الي بحددله عدد ال pods او ال containers الي محتاجها؟**. أيوه، أنت اللي بتحدد الرقم اللي إنت عايزه في ملف الإعدادات، وكوبرنيتس بيضمن إن الرقم ده يفضل شغال مهما حصل.

الـ`Kubernetes` بيوفر ميزة (self-healing)، لو حاوية وقعت هو بيقومها لوحده. وده بيخليه مختلف عن الكلاود العادي. طيب **هو مش الكلاود بيضمنلي حته ال high availability انا ليه محتاج (K8s) Kubernetes؟**. لأن الكلاود بيضمن سلامة "السيرفر" كقطعة حديد، لكن كوبرنيتس بيضمن سلامة "التطبيق" اللي شغال جوه السيرفر، وده الأهم.

بعد الـDeployment مهندس الDevOps بيستخدم **`Prometheus`** عشان يجمع البيانات، و **`Grafana`** عشان يعرضها ويراقب كل حاجة. وفي بعض الأحيان، مهندس الDevOps ممكن يستخدم أداة زي **`Ansible`** عشان يجهز الإعدادات الداخلية للسيرفرات بشكل موحد، زي تثبيت برامج معينة عليها. وده يوضح لنا **إيه دور `Jenkins` و `Ansible` في القصة دي**. 

**`كدا نقدر نقول ان بقا عندنا اول Realse من الـApplication`**

**هل بعد ما بعمل كل السكريبتات دي كلها ويبدا يطلع اول release للنور انا دوري انتهي كدا بعمل بس monitoring وبتدخل لو حصل حاجة؟**. الإجابة قاطعة: لأ. دورك كمهندس ديفاوبس بيتحول من كتابة الاسكريبتات الي هتساعدك تعمل كل ده إلى التحسين المستمر (Continuous Improvement)، المهام الي بتخلي الـSystem أسرع، أرخص، آمن.

**🤐يعني يا كينج دورك مبيخلصش وهيطلع عينك**



### **افرض بقا عاوزين نضيف Feature!**


بص يا كينج، دلوقتي الأبلكيشن بتاعنا طلع للنور والناس بتستخدمه. فجأة الي كان طالب الابلكيشن ده قالك: "أنا عايز أضيف ميزة الدفع بالـ `QR Code` عشان نكسر الدنيا! يارجاليية".

هنا بقى بتظهر حلاوة كل التعب اللي اتعمل في الأول. الموضوع مبقاش مرهق زي الاول بقا بص كدا ...

**اول حاجة التخطيط على رواقة (`Agile & Jira`):** الفريق بيقعد قعدة عرب، ويبدأ **`Sprint`** جديد. بيفتحوا **`Jira`** ويعملوا **`Ticket`** جديدة للميزة دي، ويكسروها حتت صغيرة عشان الشغل يبقى سهل.

**بعد كدا الرفع ع الريبو** كفتجي الكود مش بيخترع العجلة. بيروح على جهازه ويكتب أمر واحد بسيط:
    `git checkout -b feature/qr-payment`

كده كأنه خد "نسخة" من الكود الأصلي عشان يرسم عليها براحته من غير ما يشخبط على الأصل اللي عند الناس.


**لحظة السحر: الـ `Pipeline` بيشتغل تاني لوحده**

بعد ما الزبون يخلص إبداعه ف الكود ويعمل **`push`** للكود بتاعه على **`GitHub`**، الـ **`CI/CD Pipeline`** اللي كان نايم بيصحى ويبدأ يشتغل لوحده.

 نفس الـPipeline بيشتغل تاني بنفس المراحل (**`stages`**):

 
**ال`Build`:** بياخد الكود الجديد ويجمعه.

**ال`Test`:** بيشغل كل الاختبارات القديمة والجديدة اللي المبرمج المحترم كتبها عشان يتأكد إن الشغل الجديد متين ومبوظش حاجة كانت سليمة قبل كدا.
 
**ال`Package`:** بيغلف الكود النضيف ده في **`Docker Image`** جديدة ليها رقم إصدار (**`version`**) جديد، زي `v1.1` فاكر لما الـ`Major, Minor and Batch` اتشرحوا !!.


**البروفة الأخيرة على الـ `Staging`**

الـ `Pipeline` بياخد الـ `Image` الجديدة دي ويرميها على الـ **`Staging Environment`**. ده بقا نسخة طبق الأصل من السيرفر الحقيقي بس محدش بيشوفه غيرنا.

الـ **`Tester`** بيدخل يتأكد إن كل حاجة في الميزة الجديدة شغالة تمام التمام.

#### **وقت الجد بقا: الـ `Production Deployment`**

بعد ما الـ `Tester` يدينا إشارة "كله تمام"، وبضغطة زرار واحدة، الـ **`CD Pipeline`** بياخد الـ `Image` الجديدة ويديها لراس الافعي **`Kubernetes`** (بيني وبينها ضغينة شخصية).

الـ`Kubernetes` هنا بيبين معلمته. مش بيقفل الأبلكيشن كله عشان يحدثه، لأ، ده بيعمل حاجة جامدة كدا اسمها **`Rolling Update`**. يعني بالراحة كده، بيشيل `pod` (Container) قديمة ويحط واحدة جديدة مكانها، وبعدين اللي بعدها، وهكذا... كل ده والناس شغالة على الأبلكيشن من غير ما يحسوا بأي حاجة ولا الخدمة تقف ثانية.

## **`اوعى الـDown Time يسطا`**


#### **العين الساهرة ودور مهندس الديف أوبس الغلبان**

طبعاً مهندس الديف أوبس مش قاعد بيتفرج للاسف. دوره دلوقتي إنه زي الصقر، بيراقب الـ **`Dashboards`** على **`Grafana`** عشان يشوف أداء الميزة الجديدة دي عامل إزاي. هل سريعة؟ هل فيها أي `errors`؟ بيبقى جاهز يتدخل في أي لحظة.

---
### **الزتونة بقا**

كل التعب اللي في الأول عشان تبني **`Infrastructure`** و **`Pipelines`** صح، بيخلي إضافة أي حاجة جديدة بعد كده عملية روتينية، سريعة، وآمنة. بدل ما كانت قصة وحوار، بقت مجرد `push` وانت بتتفرج على السحر وهو بيحصل.

**يعني من الآخر، بتتعب مرة واحدة صح، عشان تفضل تنجز وتضيف قيمة طول عمر المشروع.**


> # **انا كدا خلصت اتمني تكون القصة كانت لطيفة وفيها الي محتاج تعرفه عن **`الDevOps Mindset`** ببساطة جدا**

> # **لو في اي تعليق ممكن تعدل ف الفايل ده وتبعته تاني 🤠🤺**


